/*
 * Copyright 2009-2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//===========================================
// Basic
//===========================================

apply plugin: 'groovy'

defaultTasks 'clean', 'test'

sourceCompatibility = 1.7
targetCompatibility = 1.7

repositories {
    mavenCentral()
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.1.5'
    compile 'commons-cli:commons-cli:1.2'
    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
}

sourceSets {
    main {
        resources {
            srcDir 'src/resources'
        }
        output.resourcesDir = 'build/improx-resources'
    }
    test {
        groovy {
            srcDir 'test/functional'
        }
    }
}

def defaultEncoding = 'UTF-8'
tasks.withType(AbstractCompile) each { it.options.encoding = defaultEncoding }
tasks.withType(GroovyCompile) each { it.groovyOptions.encoding = defaultEncoding }

//===========================================
// Tasks
//===========================================

def grailsServerProc

task startGrails << {
    println ">> Starting Grails..."
    Thread.start {
        ProcessUtil.execute(["sh", "-c", "${projectDir}/grailsw"], projectDir) { proc ->
            grailsServerProc = proc
            proc << "improx-start\n"
        }
    }
    SocketUtil.waitForPortAvailable(8096)
    println ">> Improx server started."
}

task stopGrails << {
    println ">> Stopping Grails..."
    grailsServerProc << "improx-stop\n"
    SocketUtil.waitForPortDisavailable(8096)
    println ">> Improx server stopped."
    grailsServerProc << "exit\n"
    println ">> Grails stopped."
}

test.doFirst { startGrails.execute() }
test.doLast { stopGrails.execute() }

task wrapper(type: Wrapper) {
    gradleVersion = '1.6'
}

task docs << {
    ProcessUtil.execute(["grails", "doc"], projectDir)
    ProcessUtil.execute(["git", "checkout", "gh-pages"], projectDir)
    copy {
        from "$projectDir/target/docs"
        into "$projectDir"
    }
    println ""
    println "NOTICE: Please check the diff and then commit if no problem."
}

//===========================================
// Helper
//===========================================

class ProcessUtil {
    static execute(List command, File currentDir, Closure procHandler = null) {
        println "Executing '${command.join(' ')}' at ${currentDir} ..."
        def env = ['HOME', 'JAVA_HOME'].collect { "${it}=${System.env[it]}" }
        doExecute({ command.execute(env, currentDir) }, procHandler)
    }

    private static doExecute(execClosure, procHandler = null) {
        try {
            def proc = execClosure.call()

            // Delegate stdout/stderr to System.out/err
            // it's very important to disable a close method, because waitForProcessOutput
            // will automatically close the streams.
            def out = new FilterOutputStream(System.out) { void close() { /* do nothing */ } }
            def err = new FilterOutputStream(System.err) { void close() { /* do nothing */ } }
            proc.consumeProcessOutput(out, err)

            if (procHandler) {
                procHandler.call(proc)
            }
            proc.waitFor()

            return proc

        } catch (IOException e) {
            if (e.message =~ /^Cannot run program/) return false
            throw e
        }
    }
}

class SocketUtil {
    static waitForPortAvailable(int port) {
        while (true) {
            try {
                withSocket('localhost', port) { /* do nothing (only to connect) */ }
                break
            } catch (ConnectException e) {
                // next loop
            }
            sleep 1000
        }
    }

    static waitForPortDisavailable(int port) {
        while (true) {
            try {
                withSocket('localhost', port) { /* do nothing (only to connect) */ }
                // next loop
            } catch (ConnectException e) {
                break
            }
            sleep 1000
        }
    }

    private static withSocket(host, port, closure) {
        def socket
        try {
            socket = new Socket(host, port)
            closure.call(socket)
        } finally {
            socket?.close()
        }
    }
}

