/*
 * Copyright 2009-2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//===========================================
// Basic
//===========================================

apply plugin: 'groovy'

defaultTasks 'clean', 'test'

sourceCompatibility = 1.7
targetCompatibility = 1.7

repositories {
    mavenCentral()
}

dependencies {
    groovy 'org.codehaus.groovy:groovy-all:2.0.5'
    groovy 'commons-cli:commons-cli:1.2'
    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
}

sourceSets {
    main {
        resources {
            srcDir 'src/resources'
        }
        output.resourcesDir = 'build/improx-resources'
    }
    test {
        groovy {
            srcDir 'test/functional'
        }
    }
}

def defaultEncoding = 'UTF-8'
tasks.withType(AbstractCompile) each { it.options.encoding = defaultEncoding }
tasks.withType(GroovyCompile) each { it.groovyOptions.encoding = defaultEncoding }

//===========================================
// Tasks
//===========================================

task startGrails << {
    println ">> Starting Grails..."
    Thread.start {
        ProcessUtil.execute(["sh", "-c", "${projectDir}/grailsw"], projectDir) { proc ->
            ext.grailsServerProc = proc
            proc.out << "improx-start\n"
        }
    }
    while (true) {
        try {
            withSocket('localhost', 8096) { /* do nothing (only to connect) */ }
            break
        } catch (ConnectException e) {
            // next loop
        }
    }
    println ">> Improx server started."
}

task stopGrails << {
    println ">> Stopping Grails..."
    withSocket('localhost', 8096) { socket ->
        socket << "improx-stop\n"
        println socket.inputStream.text
    }
    sleep 1000
    startGrails.grailsServerProc?.destroy()
    println ">> Stopped."
}

test.doFirst { startGrails.execute() }
test.doLast { stopGrails.execute() }

task wrapper(type: Wrapper) {
    gradleVersion = '1.3'
}

//===========================================
// Helper
//===========================================

def withSocket(host, port, closure) {
    def socket
    try {
        socket = new Socket(host, port)
        closure.call(socket)
    } finally {
        socket?.close()
    }
}

class ProcessUtil {
    static execute(List command, File currentDir, Closure procHandler) {
        println "Executing '${command.join(' ')}' at ${currentDir} ..."
        def env = ['HOME', 'JAVA_HOME'].collect { "${it}=${System.env[it]}" }
        doExecute({ command.execute(env, currentDir) }, procHandler)
    }

    private static doExecute(execClosure, procHandler) {
        try {
            def proc = execClosure.call()

            // Delegate stdout/stderr to System.out/err
            // it's very important to disable a close method, because waitForProcessOutput
            // will automatically close the streams.
            def out = new FilterOutputStream(System.out) { void close() { /* do nothing */ } }
            def err = new FilterOutputStream(System.err) { void close() { /* do nothing */ } }
            procHandler.call(proc)
            proc.waitForProcessOutput(out, err)

            return true

        } catch (IOException e) {
            if (e.message =~ /^Cannot run program/) return false
            throw e
        }
    }
}
